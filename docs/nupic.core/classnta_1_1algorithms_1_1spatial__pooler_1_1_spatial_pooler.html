<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>NuPIC Core: nta::algorithms::spatial_pooler::SpatialPooler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="numenta-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">NuPIC Core
   </div>
   <div id="projectbrief">Core algorithms for NuPIC(the Numenta Platform for Intelligent Computing), implemented in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenta.html">nta</a></li><li class="navelem"><b>algorithms</b></li><li class="navelem"><b>spatial_pooler</b></li><li class="navelem"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html">SpatialPooler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nta::algorithms::spatial_pooler::SpatialPooler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CLA spatial pooler implementation in C++.  
 <a href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_spatial_pooler_8hpp_source.html">SpatialPooler.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1d3e0888ccb36dbdc77bf8758f97e351"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a1d3e0888ccb36dbdc77bf8758f97e351">initialize</a> (vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; inputDimensions, vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; columnDimensions, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> potentialRadius=16, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> potentialPct=0.5, bool globalInhibition=true, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> localAreaDensity=-1.0, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> numActiveColumnsPerInhArea=10, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> stimulusThreshold=0, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> synPermInactiveDec=0.01, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> synPermActiveInc=0.1, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> synPermConnected=0.1, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> minPctOverlapDutyCycles=0.001, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> minPctActiveDutyCycles=0.001, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> dutyCyclePeriod=1000, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> maxBoost=10.0, <a class="el" href="namespacenta.html#a17d4a8b25826d8927b44cdbb41109e1b">Int</a> seed=1, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> spVerbosity=0, bool wrapAround=true)</td></tr>
<tr class="memdesc:a1d3e0888ccb36dbdc77bf8758f97e351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the spatial pooler using the given parameters.  <a href="#a1d3e0888ccb36dbdc77bf8758f97e351">More...</a><br /></td></tr>
<tr class="separator:a1d3e0888ccb36dbdc77bf8758f97e351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f905c3b405015a22c8b369b78918e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ae4f905c3b405015a22c8b369b78918e4">compute</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> inputVector[], bool learn, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> activeVector[], bool stripNeverLearned)</td></tr>
<tr class="memdesc:ae4f905c3b405015a22c8b369b78918e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the main workshorse method of the <a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html" title="CLA spatial pooler implementation in C++. ">SpatialPooler</a> class.  <a href="#ae4f905c3b405015a22c8b369b78918e4">More...</a><br /></td></tr>
<tr class="separator:ae4f905c3b405015a22c8b369b78918e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570b86ba1a235976ec8e9006330654a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a570b86ba1a235976ec8e9006330654a6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a570b86ba1a235976ec8e9006330654a6">compute</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> inputVector[], bool learn, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> activeVector[])</td></tr>
<tr class="memdesc:a570b86ba1a235976ec8e9006330654a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but with stripUnlearnedColumns set to true. <br /></td></tr>
<tr class="separator:a570b86ba1a235976ec8e9006330654a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc0cbb92811f66597595db76838aef3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#aacc0cbb92811f66597595db76838aef3">stripUnlearnedColumns</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> activeArray[])</td></tr>
<tr class="memdesc:aacc0cbb92811f66597595db76838aef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the set of columns who have never been active from the set of active columns selected in the inhibition round.  <a href="#aacc0cbb92811f66597595db76838aef3">More...</a><br /></td></tr>
<tr class="separator:aacc0cbb92811f66597595db76838aef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e9438994e241bc75cb23e868c28c7e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a38e9438994e241bc75cb23e868c28c7e">version</a> () const </td></tr>
<tr class="memdesc:a38e9438994e241bc75cb23e868c28c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the version number of this spatial pooler.  <a href="#a38e9438994e241bc75cb23e868c28c7e">More...</a><br /></td></tr>
<tr class="separator:a38e9438994e241bc75cb23e868c28c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aa964fa6465e4cd5c11160c602b1df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a83aa964fa6465e4cd5c11160c602b1df">save</a> (ostream &amp;outStream)</td></tr>
<tr class="memdesc:a83aa964fa6465e4cd5c11160c602b1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save (serialize) the current state of the spatial pooler to the specified output stream.  <a href="#a83aa964fa6465e4cd5c11160c602b1df">More...</a><br /></td></tr>
<tr class="separator:a83aa964fa6465e4cd5c11160c602b1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb5369451cb903ac58a4aa3944fd355"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a4fb5369451cb903ac58a4aa3944fd355">load</a> (istream &amp;inStream)</td></tr>
<tr class="memdesc:a4fb5369451cb903ac58a4aa3944fd355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load (deserialize) and initialize the spatial pooler from the specified input stream.  <a href="#a4fb5369451cb903ac58a4aa3944fd355">More...</a><br /></td></tr>
<tr class="separator:a4fb5369451cb903ac58a4aa3944fd355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317122c03fbfbe47ed0adc6ed99dfd80"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a317122c03fbfbe47ed0adc6ed99dfd80">persistentSize</a> ()</td></tr>
<tr class="memdesc:a317122c03fbfbe47ed0adc6ed99dfd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes that a save operation would result in.  <a href="#a317122c03fbfbe47ed0adc6ed99dfd80">More...</a><br /></td></tr>
<tr class="separator:a317122c03fbfbe47ed0adc6ed99dfd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ed4e9527e2429cb180903c45184a0f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a16ed4e9527e2429cb180903c45184a0f">getColumnDimensions</a> ()</td></tr>
<tr class="memdesc:a16ed4e9527e2429cb180903c45184a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimensions of the columns in the region.  <a href="#a16ed4e9527e2429cb180903c45184a0f">More...</a><br /></td></tr>
<tr class="separator:a16ed4e9527e2429cb180903c45184a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5472e7012ba87d87a30bd8e1b2fa856a"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a5472e7012ba87d87a30bd8e1b2fa856a">getInputDimensions</a> ()</td></tr>
<tr class="memdesc:a5472e7012ba87d87a30bd8e1b2fa856a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimensions of the input vector.  <a href="#a5472e7012ba87d87a30bd8e1b2fa856a">More...</a><br /></td></tr>
<tr class="separator:a5472e7012ba87d87a30bd8e1b2fa856a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b1c595c5f7067a5e5e5b0eefc97bdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ad4b1c595c5f7067a5e5e5b0eefc97bdc">getNumColumns</a> ()</td></tr>
<tr class="memdesc:ad4b1c595c5f7067a5e5e5b0eefc97bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of columns.  <a href="#ad4b1c595c5f7067a5e5e5b0eefc97bdc">More...</a><br /></td></tr>
<tr class="separator:ad4b1c595c5f7067a5e5e5b0eefc97bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c864a382247364d0d000f1aaae09c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ae4c864a382247364d0d000f1aaae09c7">getNumInputs</a> ()</td></tr>
<tr class="memdesc:ae4c864a382247364d0d000f1aaae09c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of inputs.  <a href="#ae4c864a382247364d0d000f1aaae09c7">More...</a><br /></td></tr>
<tr class="separator:ae4c864a382247364d0d000f1aaae09c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed5186a1f30973520b5accef40cf50a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a9ed5186a1f30973520b5accef40cf50a">getPotentialRadius</a> ()</td></tr>
<tr class="memdesc:a9ed5186a1f30973520b5accef40cf50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the potential radius.  <a href="#a9ed5186a1f30973520b5accef40cf50a">More...</a><br /></td></tr>
<tr class="separator:a9ed5186a1f30973520b5accef40cf50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cdd2e79511f169be0c227dc17b843e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a59cdd2e79511f169be0c227dc17b843e">setPotentialRadius</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> potentialRadius)</td></tr>
<tr class="memdesc:a59cdd2e79511f169be0c227dc17b843e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the potential radius.  <a href="#a59cdd2e79511f169be0c227dc17b843e">More...</a><br /></td></tr>
<tr class="separator:a59cdd2e79511f169be0c227dc17b843e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958bd73def7bb439beaae088bdf4ea92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a958bd73def7bb439beaae088bdf4ea92">getPotentialPct</a> ()</td></tr>
<tr class="memdesc:a958bd73def7bb439beaae088bdf4ea92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the potential percent.  <a href="#a958bd73def7bb439beaae088bdf4ea92">More...</a><br /></td></tr>
<tr class="separator:a958bd73def7bb439beaae088bdf4ea92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27f183609145489f9c78b7b9ba6e0c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#aa27f183609145489f9c78b7b9ba6e0c2">setPotentialPct</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> potentialPct)</td></tr>
<tr class="memdesc:aa27f183609145489f9c78b7b9ba6e0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the potential percent.  <a href="#aa27f183609145489f9c78b7b9ba6e0c2">More...</a><br /></td></tr>
<tr class="separator:aa27f183609145489f9c78b7b9ba6e0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbec6b93518ee58ee842cc6ab70e835d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#acbec6b93518ee58ee842cc6ab70e835d">getGlobalInhibition</a> ()</td></tr>
<tr class="separator:acbec6b93518ee58ee842cc6ab70e835d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e65e3eed0dea2e49e1a764fb6b7447"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a60e65e3eed0dea2e49e1a764fb6b7447">setGlobalInhibition</a> (bool globalInhibition)</td></tr>
<tr class="memdesc:a60e65e3eed0dea2e49e1a764fb6b7447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets global inhibition.  <a href="#a60e65e3eed0dea2e49e1a764fb6b7447">More...</a><br /></td></tr>
<tr class="separator:a60e65e3eed0dea2e49e1a764fb6b7447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95df3b49f5857465664e8fd2b5296346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a17d4a8b25826d8927b44cdbb41109e1b">Int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a95df3b49f5857465664e8fd2b5296346">getNumActiveColumnsPerInhArea</a> ()</td></tr>
<tr class="memdesc:a95df3b49f5857465664e8fd2b5296346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of active columns per inhibition area.  <a href="#a95df3b49f5857465664e8fd2b5296346">More...</a><br /></td></tr>
<tr class="separator:a95df3b49f5857465664e8fd2b5296346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81539a2ddd697ed84aff64cae980b61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#aa81539a2ddd697ed84aff64cae980b61">setNumActiveColumnsPerInhArea</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> numActiveColumnsPerInhArea)</td></tr>
<tr class="memdesc:aa81539a2ddd697ed84aff64cae980b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of active columns per inhibition area.  <a href="#aa81539a2ddd697ed84aff64cae980b61">More...</a><br /></td></tr>
<tr class="separator:aa81539a2ddd697ed84aff64cae980b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b8f0c423c18752049ed0454d49003e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a87b8f0c423c18752049ed0454d49003e">getLocalAreaDensity</a> ()</td></tr>
<tr class="memdesc:a87b8f0c423c18752049ed0454d49003e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local area density.  <a href="#a87b8f0c423c18752049ed0454d49003e">More...</a><br /></td></tr>
<tr class="separator:a87b8f0c423c18752049ed0454d49003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e54ace021693e60e7f1eca46ada520e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a8e54ace021693e60e7f1eca46ada520e">setLocalAreaDensity</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> localAreaDensity)</td></tr>
<tr class="memdesc:a8e54ace021693e60e7f1eca46ada520e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the local area density.  <a href="#a8e54ace021693e60e7f1eca46ada520e">More...</a><br /></td></tr>
<tr class="separator:a8e54ace021693e60e7f1eca46ada520e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2711ea6540528a488dab276cd081ef1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a2711ea6540528a488dab276cd081ef1d">getStimulusThreshold</a> ()</td></tr>
<tr class="memdesc:a2711ea6540528a488dab276cd081ef1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stimulus threshold.  <a href="#a2711ea6540528a488dab276cd081ef1d">More...</a><br /></td></tr>
<tr class="separator:a2711ea6540528a488dab276cd081ef1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1e7663b5fb482a3e1eb61de8bd23ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#aeb1e7663b5fb482a3e1eb61de8bd23ac">setStimulusThreshold</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> stimulusThreshold)</td></tr>
<tr class="memdesc:aeb1e7663b5fb482a3e1eb61de8bd23ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stimulus threshold.  <a href="#aeb1e7663b5fb482a3e1eb61de8bd23ac">More...</a><br /></td></tr>
<tr class="separator:aeb1e7663b5fb482a3e1eb61de8bd23ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e95b342ec37a893b62920044f89100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a77e95b342ec37a893b62920044f89100">getInhibitionRadius</a> ()</td></tr>
<tr class="memdesc:a77e95b342ec37a893b62920044f89100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inhibition radius.  <a href="#a77e95b342ec37a893b62920044f89100">More...</a><br /></td></tr>
<tr class="separator:a77e95b342ec37a893b62920044f89100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a21cc4a6691ed8f56568d00c3d8b8b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a4a21cc4a6691ed8f56568d00c3d8b8b4">setInhibitionRadius</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> inhibitionRadius)</td></tr>
<tr class="memdesc:a4a21cc4a6691ed8f56568d00c3d8b8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the inhibition radius.  <a href="#a4a21cc4a6691ed8f56568d00c3d8b8b4">More...</a><br /></td></tr>
<tr class="separator:a4a21cc4a6691ed8f56568d00c3d8b8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4083bd522642559c93e3e1996dfd688f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a4083bd522642559c93e3e1996dfd688f">getDutyCyclePeriod</a> ()</td></tr>
<tr class="memdesc:a4083bd522642559c93e3e1996dfd688f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the duty cycle period.  <a href="#a4083bd522642559c93e3e1996dfd688f">More...</a><br /></td></tr>
<tr class="separator:a4083bd522642559c93e3e1996dfd688f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdff66851e1e95e822550a3c5de66ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#aafdff66851e1e95e822550a3c5de66ac">setDutyCyclePeriod</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> dutyCyclePeriod)</td></tr>
<tr class="memdesc:aafdff66851e1e95e822550a3c5de66ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the duty cycle period.  <a href="#aafdff66851e1e95e822550a3c5de66ac">More...</a><br /></td></tr>
<tr class="separator:aafdff66851e1e95e822550a3c5de66ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c2ace266a56af74dacdbe9b94576e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ae5c2ace266a56af74dacdbe9b94576e9">getMaxBoost</a> ()</td></tr>
<tr class="memdesc:ae5c2ace266a56af74dacdbe9b94576e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum boost value.  <a href="#ae5c2ace266a56af74dacdbe9b94576e9">More...</a><br /></td></tr>
<tr class="separator:ae5c2ace266a56af74dacdbe9b94576e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac335d159fa336f187f4da46174136daa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ac335d159fa336f187f4da46174136daa">setMaxBoost</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> maxBoost)</td></tr>
<tr class="memdesc:ac335d159fa336f187f4da46174136daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum boost value.  <a href="#ac335d159fa336f187f4da46174136daa">More...</a><br /></td></tr>
<tr class="separator:ac335d159fa336f187f4da46174136daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7b28e372d13489f6f6abb93918843a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a6c7b28e372d13489f6f6abb93918843a">getIterationNum</a> ()</td></tr>
<tr class="memdesc:a6c7b28e372d13489f6f6abb93918843a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iteration number.  <a href="#a6c7b28e372d13489f6f6abb93918843a">More...</a><br /></td></tr>
<tr class="separator:a6c7b28e372d13489f6f6abb93918843a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821fc1673bf265bc26c92d98d63dbf6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a821fc1673bf265bc26c92d98d63dbf6f">setIterationNum</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> iterationNum)</td></tr>
<tr class="memdesc:a821fc1673bf265bc26c92d98d63dbf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the iteration number.  <a href="#a821fc1673bf265bc26c92d98d63dbf6f">More...</a><br /></td></tr>
<tr class="separator:a821fc1673bf265bc26c92d98d63dbf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b505840b6bd081dca77956f1c82a0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a80b505840b6bd081dca77956f1c82a0c">getIterationLearnNum</a> ()</td></tr>
<tr class="memdesc:a80b505840b6bd081dca77956f1c82a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the learning iteration number.  <a href="#a80b505840b6bd081dca77956f1c82a0c">More...</a><br /></td></tr>
<tr class="separator:a80b505840b6bd081dca77956f1c82a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4b54df2652c7bf7a35c47bbd8ac054"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#aaa4b54df2652c7bf7a35c47bbd8ac054">setIterationLearnNum</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> iterationLearnNum)</td></tr>
<tr class="memdesc:aaa4b54df2652c7bf7a35c47bbd8ac054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the learning iteration number.  <a href="#aaa4b54df2652c7bf7a35c47bbd8ac054">More...</a><br /></td></tr>
<tr class="separator:aaa4b54df2652c7bf7a35c47bbd8ac054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd576b3ee777208c8a81175671c7219"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a0cd576b3ee777208c8a81175671c7219">getSpVerbosity</a> ()</td></tr>
<tr class="memdesc:a0cd576b3ee777208c8a81175671c7219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the verbosity level.  <a href="#a0cd576b3ee777208c8a81175671c7219">More...</a><br /></td></tr>
<tr class="separator:a0cd576b3ee777208c8a81175671c7219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487656f51db4fd4bcca4ad1d7f26b273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a487656f51db4fd4bcca4ad1d7f26b273">setSpVerbosity</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> spVerbosity)</td></tr>
<tr class="memdesc:a487656f51db4fd4bcca4ad1d7f26b273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the verbosity level.  <a href="#a487656f51db4fd4bcca4ad1d7f26b273">More...</a><br /></td></tr>
<tr class="separator:a487656f51db4fd4bcca4ad1d7f26b273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc35eb29a2b307f057151753ce9800f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a8dc35eb29a2b307f057151753ce9800f">getWrapAround</a> ()</td></tr>
<tr class="memdesc:a8dc35eb29a2b307f057151753ce9800f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean value of wrapAround which indicates if receptive fields should wrap around from the beginning the input dimensions to the end.  <a href="#a8dc35eb29a2b307f057151753ce9800f">More...</a><br /></td></tr>
<tr class="separator:a8dc35eb29a2b307f057151753ce9800f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab746d72ed9619fe75d83be75eeca224d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ab746d72ed9619fe75d83be75eeca224d">setWrapAround</a> (bool wrapAround)</td></tr>
<tr class="memdesc:ab746d72ed9619fe75d83be75eeca224d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets wrapAround.  <a href="#ab746d72ed9619fe75d83be75eeca224d">More...</a><br /></td></tr>
<tr class="separator:ab746d72ed9619fe75d83be75eeca224d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e744be6cfdb423505098a1c6c69e313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a1e744be6cfdb423505098a1c6c69e313">getUpdatePeriod</a> ()</td></tr>
<tr class="memdesc:a1e744be6cfdb423505098a1c6c69e313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the update period.  <a href="#a1e744be6cfdb423505098a1c6c69e313">More...</a><br /></td></tr>
<tr class="separator:a1e744be6cfdb423505098a1c6c69e313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91eabb8c79b4f0d072153f5c4d9baec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ad91eabb8c79b4f0d072153f5c4d9baec">setUpdatePeriod</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> updatePeriod)</td></tr>
<tr class="memdesc:ad91eabb8c79b4f0d072153f5c4d9baec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the update period.  <a href="#ad91eabb8c79b4f0d072153f5c4d9baec">More...</a><br /></td></tr>
<tr class="separator:ad91eabb8c79b4f0d072153f5c4d9baec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d28bbb4d4c79370ea53923a99265a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ae6d28bbb4d4c79370ea53923a99265a8">getSynPermTrimThreshold</a> ()</td></tr>
<tr class="memdesc:ae6d28bbb4d4c79370ea53923a99265a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the permanence trim threshold.  <a href="#ae6d28bbb4d4c79370ea53923a99265a8">More...</a><br /></td></tr>
<tr class="separator:ae6d28bbb4d4c79370ea53923a99265a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8106a472483d40338be176e58c40c98f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a8106a472483d40338be176e58c40c98f">setSynPermTrimThreshold</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> synPermTrimThreshold)</td></tr>
<tr class="memdesc:a8106a472483d40338be176e58c40c98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the permanence trim threshold.  <a href="#a8106a472483d40338be176e58c40c98f">More...</a><br /></td></tr>
<tr class="separator:a8106a472483d40338be176e58c40c98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4f549c6239cfa0dd3a7f460e4cfbfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a8b4f549c6239cfa0dd3a7f460e4cfbfd">getSynPermActiveInc</a> ()</td></tr>
<tr class="memdesc:a8b4f549c6239cfa0dd3a7f460e4cfbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the permanence increment amount for active synapses inputs.  <a href="#a8b4f549c6239cfa0dd3a7f460e4cfbfd">More...</a><br /></td></tr>
<tr class="separator:a8b4f549c6239cfa0dd3a7f460e4cfbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb386453b2bf1b3a0a3d9375fff7744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a2eb386453b2bf1b3a0a3d9375fff7744">setSynPermActiveInc</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> synPermActiveInc)</td></tr>
<tr class="memdesc:a2eb386453b2bf1b3a0a3d9375fff7744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the permanence increment amount for active synapses inputs.  <a href="#a2eb386453b2bf1b3a0a3d9375fff7744">More...</a><br /></td></tr>
<tr class="separator:a2eb386453b2bf1b3a0a3d9375fff7744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94ce7edfb7d918c20ef3995739ca932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#af94ce7edfb7d918c20ef3995739ca932">getSynPermInactiveDec</a> ()</td></tr>
<tr class="memdesc:af94ce7edfb7d918c20ef3995739ca932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the permanence decrement amount for inactive synapses.  <a href="#af94ce7edfb7d918c20ef3995739ca932">More...</a><br /></td></tr>
<tr class="separator:af94ce7edfb7d918c20ef3995739ca932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4458331f6ee8724fc8e61c07ee1feacc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a4458331f6ee8724fc8e61c07ee1feacc">setSynPermInactiveDec</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> synPermInactiveDec)</td></tr>
<tr class="memdesc:a4458331f6ee8724fc8e61c07ee1feacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the permanence decrement amount for inactive synapses.  <a href="#a4458331f6ee8724fc8e61c07ee1feacc">More...</a><br /></td></tr>
<tr class="separator:a4458331f6ee8724fc8e61c07ee1feacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e52ad8321b4e1b5cbfa56c29d8cabae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a6e52ad8321b4e1b5cbfa56c29d8cabae">getSynPermBelowStimulusInc</a> ()</td></tr>
<tr class="memdesc:a6e52ad8321b4e1b5cbfa56c29d8cabae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the permanence increment amount for columns that have not been recently active.  <a href="#a6e52ad8321b4e1b5cbfa56c29d8cabae">More...</a><br /></td></tr>
<tr class="separator:a6e52ad8321b4e1b5cbfa56c29d8cabae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cda4776232272530abb308fa33c9ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ab4cda4776232272530abb308fa33c9ea">setSynPermBelowStimulusInc</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> synPermBelowStimulusInc)</td></tr>
<tr class="memdesc:ab4cda4776232272530abb308fa33c9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the permanence increment amount for columns that have not been recently active.  <a href="#ab4cda4776232272530abb308fa33c9ea">More...</a><br /></td></tr>
<tr class="separator:ab4cda4776232272530abb308fa33c9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141cd132a0d1f4d9dacd24162f67c213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a141cd132a0d1f4d9dacd24162f67c213">getSynPermConnected</a> ()</td></tr>
<tr class="memdesc:a141cd132a0d1f4d9dacd24162f67c213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the permanence amount that qualifies a synapse as being connected.  <a href="#a141cd132a0d1f4d9dacd24162f67c213">More...</a><br /></td></tr>
<tr class="separator:a141cd132a0d1f4d9dacd24162f67c213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f808284a8e8372942289d942d25004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a27f808284a8e8372942289d942d25004">setSynPermConnected</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> setSynPermConnected)</td></tr>
<tr class="memdesc:a27f808284a8e8372942289d942d25004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the permanence amount that qualifies a synapse as being connected.  <a href="#a27f808284a8e8372942289d942d25004">More...</a><br /></td></tr>
<tr class="separator:a27f808284a8e8372942289d942d25004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a9a4d472dbbb130848b25f43e9c085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a60a9a4d472dbbb130848b25f43e9c085">getMinPctOverlapDutyCycles</a> ()</td></tr>
<tr class="memdesc:a60a9a4d472dbbb130848b25f43e9c085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum tolerated overlaps, given as percent of neighbors overlap score.  <a href="#a60a9a4d472dbbb130848b25f43e9c085">More...</a><br /></td></tr>
<tr class="separator:a60a9a4d472dbbb130848b25f43e9c085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26b6d644cb0fadc6655bdee6e7494f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ab26b6d644cb0fadc6655bdee6e7494f0">setMinPctOverlapDutyCycles</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> minPctOverlapDutyCycles)</td></tr>
<tr class="memdesc:ab26b6d644cb0fadc6655bdee6e7494f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum tolerated overlaps, given as percent of neighbors overlap score.  <a href="#ab26b6d644cb0fadc6655bdee6e7494f0">More...</a><br /></td></tr>
<tr class="separator:ab26b6d644cb0fadc6655bdee6e7494f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0add71fe208929254ea753d5f42be6ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a0add71fe208929254ea753d5f42be6ea">getMinPctActiveDutyCycles</a> ()</td></tr>
<tr class="memdesc:a0add71fe208929254ea753d5f42be6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum tolerated activity duty cycle, given as percent of neighbors' activity duty cycle.  <a href="#a0add71fe208929254ea753d5f42be6ea">More...</a><br /></td></tr>
<tr class="separator:a0add71fe208929254ea753d5f42be6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952ef18d7eea8b2054c5807c9e0cb3de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a952ef18d7eea8b2054c5807c9e0cb3de">setMinPctActiveDutyCycles</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> minPctActiveDutyCycles)</td></tr>
<tr class="memdesc:a952ef18d7eea8b2054c5807c9e0cb3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum tolerated activity duty cycle, given as percent of neighbors' activity duty cycle.  <a href="#a952ef18d7eea8b2054c5807c9e0cb3de">More...</a><br /></td></tr>
<tr class="separator:a952ef18d7eea8b2054c5807c9e0cb3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07be4b1f4e09bc9a61357358695632c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a07be4b1f4e09bc9a61357358695632c9">getBoostFactors</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> boostFactors[])</td></tr>
<tr class="memdesc:a07be4b1f4e09bc9a61357358695632c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boost factors for all columns.  <a href="#a07be4b1f4e09bc9a61357358695632c9">More...</a><br /></td></tr>
<tr class="separator:a07be4b1f4e09bc9a61357358695632c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495a44ea6eca04fb8f7f9c3ebd02ecb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a495a44ea6eca04fb8f7f9c3ebd02ecb1">setBoostFactors</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> boostFactors[])</td></tr>
<tr class="memdesc:a495a44ea6eca04fb8f7f9c3ebd02ecb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the boost factors for all columns.  <a href="#a495a44ea6eca04fb8f7f9c3ebd02ecb1">More...</a><br /></td></tr>
<tr class="separator:a495a44ea6eca04fb8f7f9c3ebd02ecb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862764b9a281e62e3d06ca9e4eee9ae1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a862764b9a281e62e3d06ca9e4eee9ae1">getOverlapDutyCycles</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> overlapDutyCycles[])</td></tr>
<tr class="memdesc:a862764b9a281e62e3d06ca9e4eee9ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the overlap duty cycles for all columns.  <a href="#a862764b9a281e62e3d06ca9e4eee9ae1">More...</a><br /></td></tr>
<tr class="separator:a862764b9a281e62e3d06ca9e4eee9ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa655081fba2fd54e16639b16377de46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#aaa655081fba2fd54e16639b16377de46">setOverlapDutyCycles</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> overlapDutyCycles[])</td></tr>
<tr class="memdesc:aaa655081fba2fd54e16639b16377de46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the overlap duty cycles for all columns.  <a href="#aaa655081fba2fd54e16639b16377de46">More...</a><br /></td></tr>
<tr class="separator:aaa655081fba2fd54e16639b16377de46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1576b0089512d735a7296f83e30dc49b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a1576b0089512d735a7296f83e30dc49b">getActiveDutyCycles</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> activeDutyCycles[])</td></tr>
<tr class="memdesc:a1576b0089512d735a7296f83e30dc49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the activity duty cycles for all columns.  <a href="#a1576b0089512d735a7296f83e30dc49b">More...</a><br /></td></tr>
<tr class="separator:a1576b0089512d735a7296f83e30dc49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e57c2e38675a8f635ed34f49afcf2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a02e57c2e38675a8f635ed34f49afcf2b">setActiveDutyCycles</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> activeDutyCycles[])</td></tr>
<tr class="memdesc:a02e57c2e38675a8f635ed34f49afcf2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the activity duty cycles for all columns.  <a href="#a02e57c2e38675a8f635ed34f49afcf2b">More...</a><br /></td></tr>
<tr class="separator:a02e57c2e38675a8f635ed34f49afcf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10236285f9a464ce4ba11f1f066d66b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a10236285f9a464ce4ba11f1f066d66b1">getMinOverlapDutyCycles</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> minOverlapDutyCycles[])</td></tr>
<tr class="memdesc:a10236285f9a464ce4ba11f1f066d66b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum overlap duty cycles for all columns.  <a href="#a10236285f9a464ce4ba11f1f066d66b1">More...</a><br /></td></tr>
<tr class="separator:a10236285f9a464ce4ba11f1f066d66b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d0d7289827535a4b5f4bfc86d39ffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ae6d0d7289827535a4b5f4bfc86d39ffe">setMinOverlapDutyCycles</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> minOverlapDutyCycles[])</td></tr>
<tr class="memdesc:ae6d0d7289827535a4b5f4bfc86d39ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum overlap duty cycles for all columns.  <a href="#ae6d0d7289827535a4b5f4bfc86d39ffe">More...</a><br /></td></tr>
<tr class="separator:ae6d0d7289827535a4b5f4bfc86d39ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf43a72aff541e81e9d39ea2cf18b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#afcf43a72aff541e81e9d39ea2cf18b43">getMinActiveDutyCycles</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> minActiveDutyCycles[])</td></tr>
<tr class="memdesc:afcf43a72aff541e81e9d39ea2cf18b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum activity duty cycles for all columns.  <a href="#afcf43a72aff541e81e9d39ea2cf18b43">More...</a><br /></td></tr>
<tr class="separator:afcf43a72aff541e81e9d39ea2cf18b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bb97ad7efcf05c220ea027e01e766e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a47bb97ad7efcf05c220ea027e01e766e">setMinActiveDutyCycles</a> (<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> minActiveDutyCycles[])</td></tr>
<tr class="memdesc:a47bb97ad7efcf05c220ea027e01e766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum activity duty cycles for all columns.  <a href="#a47bb97ad7efcf05c220ea027e01e766e">More...</a><br /></td></tr>
<tr class="separator:a47bb97ad7efcf05c220ea027e01e766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9015b431ceb397dc770082af900a3d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ab9015b431ceb397dc770082af900a3d6">getPotential</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> potential[])</td></tr>
<tr class="memdesc:ab9015b431ceb397dc770082af900a3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the potential mapping for a given column.  <a href="#ab9015b431ceb397dc770082af900a3d6">More...</a><br /></td></tr>
<tr class="separator:ab9015b431ceb397dc770082af900a3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372eae71c4fd5d9ffe9c0f8de3e02f02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a372eae71c4fd5d9ffe9c0f8de3e02f02">setPotential</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> potential[])</td></tr>
<tr class="memdesc:a372eae71c4fd5d9ffe9c0f8de3e02f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the potential mapping for a given column.  <a href="#a372eae71c4fd5d9ffe9c0f8de3e02f02">More...</a><br /></td></tr>
<tr class="separator:a372eae71c4fd5d9ffe9c0f8de3e02f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6847e121ebde30d7107781449e47f4a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a6847e121ebde30d7107781449e47f4a2">getPermanence</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> permanence[])</td></tr>
<tr class="memdesc:a6847e121ebde30d7107781449e47f4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the permanence values for a given column.  <a href="#a6847e121ebde30d7107781449e47f4a2">More...</a><br /></td></tr>
<tr class="separator:a6847e121ebde30d7107781449e47f4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace58dd7de19a87fc4587591c89729ebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ace58dd7de19a87fc4587591c89729ebd">setPermanence</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> permanence[])</td></tr>
<tr class="memdesc:ace58dd7de19a87fc4587591c89729ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the permanence values for a given column.  <a href="#ace58dd7de19a87fc4587591c89729ebd">More...</a><br /></td></tr>
<tr class="separator:ace58dd7de19a87fc4587591c89729ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56781059bc62f8c39049a767f69106e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a56781059bc62f8c39049a767f69106e6">getConnectedSynapses</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> connectedSynapses[])</td></tr>
<tr class="memdesc:a56781059bc62f8c39049a767f69106e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connected synapses for a given column.  <a href="#a56781059bc62f8c39049a767f69106e6">More...</a><br /></td></tr>
<tr class="separator:a56781059bc62f8c39049a767f69106e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad033bde8fbab993a87186aaeb1b54709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ad033bde8fbab993a87186aaeb1b54709">getConnectedCounts</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> connectedCounts[])</td></tr>
<tr class="memdesc:ad033bde8fbab993a87186aaeb1b54709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of connected synapses for all columns.  <a href="#ad033bde8fbab993a87186aaeb1b54709">More...</a><br /></td></tr>
<tr class="separator:ad033bde8fbab993a87186aaeb1b54709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb72a6c2dfaad3f467a0a96bac93df8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb72a6c2dfaad3f467a0a96bac93df8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#afb72a6c2dfaad3f467a0a96bac93df8d">printParameters</a> ()</td></tr>
<tr class="memdesc:afb72a6c2dfaad3f467a0a96bac93df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the main SP creation parameters to stdout. <br /></td></tr>
<tr class="separator:afb72a6c2dfaad3f467a0a96bac93df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fed3797d6c30b898b9a798bb70094d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a08fed3797d6c30b898b9a798bb70094d">mapColumn_</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column)</td></tr>
<tr class="memdesc:a08fed3797d6c30b898b9a798bb70094d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a column to its respective input index, keeping to the topology of the region.  <a href="#a08fed3797d6c30b898b9a798bb70094d">More...</a><br /></td></tr>
<tr class="separator:a08fed3797d6c30b898b9a798bb70094d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde1873c29f01b04ce7ae65aaf604142"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#abde1873c29f01b04ce7ae65aaf604142">mapPotential_</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column, bool wrapAround)</td></tr>
<tr class="memdesc:abde1873c29f01b04ce7ae65aaf604142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a column to its input bits.  <a href="#abde1873c29f01b04ce7ae65aaf604142">More...</a><br /></td></tr>
<tr class="separator:abde1873c29f01b04ce7ae65aaf604142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a81771becb1fe3e37b0bf1c3ec7b879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a0a81771becb1fe3e37b0bf1c3ec7b879">initPermConnected_</a> ()</td></tr>
<tr class="memdesc:a0a81771becb1fe3e37b0bf1c3ec7b879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a randomly generated permanence value for a synapses that is initialized in a connected state.  <a href="#a0a81771becb1fe3e37b0bf1c3ec7b879">More...</a><br /></td></tr>
<tr class="separator:a0a81771becb1fe3e37b0bf1c3ec7b879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cd62c4aeac1fd463db337a4830d56d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ad2cd62c4aeac1fd463db337a4830d56d">initPermNonConnected_</a> ()</td></tr>
<tr class="memdesc:ad2cd62c4aeac1fd463db337a4830d56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a randomly generated permanence value for a synapses that is to be initialized in a non-connected state.  <a href="#ad2cd62c4aeac1fd463db337a4830d56d">More...</a><br /></td></tr>
<tr class="separator:ad2cd62c4aeac1fd463db337a4830d56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4039e5a6f225e436217d1cadf5eb307a"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a4039e5a6f225e436217d1cadf5eb307a">initPermanence_</a> (vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;potential, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> connectedPct)</td></tr>
<tr class="memdesc:a4039e5a6f225e436217d1cadf5eb307a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the permanences of a column.  <a href="#a4039e5a6f225e436217d1cadf5eb307a">More...</a><br /></td></tr>
<tr class="separator:a4039e5a6f225e436217d1cadf5eb307a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682ae196f8ca597ed4215c20e5a1078a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a682ae196f8ca597ed4215c20e5a1078a">updatePermanencesForColumn_</a> (vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt; &amp;perm, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column, bool raisePerm=true)</td></tr>
<tr class="memdesc:a682ae196f8ca597ed4215c20e5a1078a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method updates the permanence matrix with a column's new permanence values.  <a href="#a682ae196f8ca597ed4215c20e5a1078a">More...</a><br /></td></tr>
<tr class="separator:a682ae196f8ca597ed4215c20e5a1078a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8c8623a959e1afb557435218d6b650"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a8b8c8623a959e1afb557435218d6b650">calculateOverlap_</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> inputVector[], vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;overlap)</td></tr>
<tr class="memdesc:a8b8c8623a959e1afb557435218d6b650"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines each column's overlap with the current input vector.  <a href="#a8b8c8623a959e1afb557435218d6b650">More...</a><br /></td></tr>
<tr class="separator:a8b8c8623a959e1afb557435218d6b650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac822ec730fac5fcfc6fec441da2630b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ac822ec730fac5fcfc6fec441da2630b1">inhibitColumns_</a> (vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt; &amp;overlaps, vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;activeColumns)</td></tr>
<tr class="memdesc:ac822ec730fac5fcfc6fec441da2630b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inhibition.  <a href="#ac822ec730fac5fcfc6fec441da2630b1">More...</a><br /></td></tr>
<tr class="separator:ac822ec730fac5fcfc6fec441da2630b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756561560cb4d74617e992b61bf0f902"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a756561560cb4d74617e992b61bf0f902">inhibitColumnsGlobal_</a> (vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt; &amp;overlaps, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> density, vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;activeColumns)</td></tr>
<tr class="memdesc:a756561560cb4d74617e992b61bf0f902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform global inhibition.  <a href="#a756561560cb4d74617e992b61bf0f902">More...</a><br /></td></tr>
<tr class="separator:a756561560cb4d74617e992b61bf0f902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad48983bb2fe2d0968684f18ef3bacd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#afad48983bb2fe2d0968684f18ef3bacd">inhibitColumnsLocal_</a> (vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt; &amp;overlaps, <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> density, vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;activeColumns)</td></tr>
<tr class="memdesc:afad48983bb2fe2d0968684f18ef3bacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs local inhibition.  <a href="#afad48983bb2fe2d0968684f18ef3bacd">More...</a><br /></td></tr>
<tr class="separator:afad48983bb2fe2d0968684f18ef3bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6503822b4ea9739917ac71858c5634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#aad6503822b4ea9739917ac71858c5634">getNeighbors1D_</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column, vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;dimensions, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> radius, bool wrapAround, vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;neighbors)</td></tr>
<tr class="memdesc:aad6503822b4ea9739917ac71858c5634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of indices corresponding to the neighbors of a given column.  <a href="#aad6503822b4ea9739917ac71858c5634">More...</a><br /></td></tr>
<tr class="separator:aad6503822b4ea9739917ac71858c5634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daf69fbe52b34f44d78b0a5671485de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a0daf69fbe52b34f44d78b0a5671485de">getNeighbors2D_</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column, vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;dimensions, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> radius, bool wrapAround, vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;neighbors)</td></tr>
<tr class="memdesc:a0daf69fbe52b34f44d78b0a5671485de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of indices corresponding to the neighbors of a given column.  <a href="#a0daf69fbe52b34f44d78b0a5671485de">More...</a><br /></td></tr>
<tr class="separator:a0daf69fbe52b34f44d78b0a5671485de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbd6eacd41dbf5b626505aa385447ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a8bbd6eacd41dbf5b626505aa385447ff">getNeighborsND_</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column, vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;dimensions, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> radius, bool wrapAround, vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;neighbors)</td></tr>
<tr class="memdesc:a8bbd6eacd41dbf5b626505aa385447ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to _getNeighbors1D and _getNeighbors2D, this function returns a list of indices corresponding to the neighbors of a given column.  <a href="#a8bbd6eacd41dbf5b626505aa385447ff">More...</a><br /></td></tr>
<tr class="separator:a8bbd6eacd41dbf5b626505aa385447ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183aba2789bfe50946739cdc38f5c89d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a183aba2789bfe50946739cdc38f5c89d">adaptSynapses_</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> inputVector[], vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;activeColumns)</td></tr>
<tr class="memdesc:a183aba2789bfe50946739cdc38f5c89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The primary method in charge of learning.  <a href="#a183aba2789bfe50946739cdc38f5c89d">More...</a><br /></td></tr>
<tr class="separator:a183aba2789bfe50946739cdc38f5c89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cf440226ede079b927e5459ef58bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a17cf440226ede079b927e5459ef58bb9">bumpUpWeakColumns_</a> ()</td></tr>
<tr class="memdesc:a17cf440226ede079b927e5459ef58bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method increases the permanence values of synapses of columns whose activity level has been too low.  <a href="#a17cf440226ede079b927e5459ef58bb9">More...</a><br /></td></tr>
<tr class="separator:a17cf440226ede079b927e5459ef58bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0777f2ceee25e1cdded45cca79374a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a0777f2ceee25e1cdded45cca79374a57">updateInhibitionRadius_</a> ()</td></tr>
<tr class="memdesc:a0777f2ceee25e1cdded45cca79374a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the inhibition radius.  <a href="#a0777f2ceee25e1cdded45cca79374a57">More...</a><br /></td></tr>
<tr class="separator:a0777f2ceee25e1cdded45cca79374a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9e816078df4284842b8e2494676a3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a1d9e816078df4284842b8e2494676a3a">avgColumnsPerInput_</a> ()</td></tr>
<tr class="memdesc:a1d9e816078df4284842b8e2494676a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">REturns the average number of columns per input, taking into account the topology of the inputs and columns.  <a href="#a1d9e816078df4284842b8e2494676a3a">More...</a><br /></td></tr>
<tr class="separator:a1d9e816078df4284842b8e2494676a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ee897199c24b56a1b0be1efca65aee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ac1ee897199c24b56a1b0be1efca65aee">avgConnectedSpanForColumn1D_</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column)</td></tr>
<tr class="memdesc:ac1ee897199c24b56a1b0be1efca65aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The range of connected synapses for column.  <a href="#ac1ee897199c24b56a1b0be1efca65aee">More...</a><br /></td></tr>
<tr class="separator:ac1ee897199c24b56a1b0be1efca65aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad93f11e2d4574ac31cc37051442aa91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#aad93f11e2d4574ac31cc37051442aa91">avgConnectedSpanForColumn2D_</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column)</td></tr>
<tr class="memdesc:aad93f11e2d4574ac31cc37051442aa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">The range of connectedSynapses per column, averaged for each dimension.  <a href="#aad93f11e2d4574ac31cc37051442aa91">More...</a><br /></td></tr>
<tr class="separator:aad93f11e2d4574ac31cc37051442aa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30725e371ede94fc0c7c6d0170cf882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#ac30725e371ede94fc0c7c6d0170cf882">avgConnectedSpanForColumnND_</a> (<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> column)</td></tr>
<tr class="memdesc:ac30725e371ede94fc0c7c6d0170cf882"><td class="mdescLeft">&#160;</td><td class="mdescRight">The range of connectedSynapses per column, averaged for each dimension.  <a href="#ac30725e371ede94fc0c7c6d0170cf882">More...</a><br /></td></tr>
<tr class="separator:ac30725e371ede94fc0c7c6d0170cf882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95f902fd98059835d8ac43110c1cc31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#aa95f902fd98059835d8ac43110c1cc31">updateMinDutyCycles_</a> ()</td></tr>
<tr class="memdesc:aa95f902fd98059835d8ac43110c1cc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the minimum duty cycles defining normal activity for a column.  <a href="#aa95f902fd98059835d8ac43110c1cc31">More...</a><br /></td></tr>
<tr class="separator:aa95f902fd98059835d8ac43110c1cc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ba1935b646d5395b324b0c5f6efa49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a91ba1935b646d5395b324b0c5f6efa49">updateMinDutyCyclesGlobal_</a> ()</td></tr>
<tr class="memdesc:a91ba1935b646d5395b324b0c5f6efa49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the minimum duty cycles in a global fashion.  <a href="#a91ba1935b646d5395b324b0c5f6efa49">More...</a><br /></td></tr>
<tr class="separator:a91ba1935b646d5395b324b0c5f6efa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff87a26bd2b583785a324a1c9237ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a3ff87a26bd2b583785a324a1c9237ed5">updateMinDutyCyclesLocal_</a> ()</td></tr>
<tr class="memdesc:a3ff87a26bd2b583785a324a1c9237ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the minimum duty cycles.  <a href="#a3ff87a26bd2b583785a324a1c9237ed5">More...</a><br /></td></tr>
<tr class="separator:a3ff87a26bd2b583785a324a1c9237ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccaea276c025b6a2c894c65ec395db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a8ccaea276c025b6a2c894c65ec395db3">updateDutyCycles_</a> (vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;overlaps, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> activeArray[])</td></tr>
<tr class="memdesc:a8ccaea276c025b6a2c894c65ec395db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the duty cycles for each column.  <a href="#a8ccaea276c025b6a2c894c65ec395db3">More...</a><br /></td></tr>
<tr class="separator:a8ccaea276c025b6a2c894c65ec395db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3664cfdfc194e59d8f4d05942534aabf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a3664cfdfc194e59d8f4d05942534aabf">updateBoostFactors_</a> ()</td></tr>
<tr class="memdesc:a3664cfdfc194e59d8f4d05942534aabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the boost factors for all columns.  <a href="#a3664cfdfc194e59d8f4d05942534aabf">More...</a><br /></td></tr>
<tr class="separator:a3664cfdfc194e59d8f4d05942534aabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8deb32d2838ef8426f0d6365c40cd3b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a8deb32d2838ef8426f0d6365c40cd3b0">updateBookeepingVars_</a> (bool learn)</td></tr>
<tr class="memdesc:a8deb32d2838ef8426f0d6365c40cd3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates counter instance variables each round.  <a href="#a8deb32d2838ef8426f0d6365c40cd3b0">More...</a><br /></td></tr>
<tr class="separator:a8deb32d2838ef8426f0d6365c40cd3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cec153fbd1ca48bf092a1c7bb1cc2f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a6cec153fbd1ca48bf092a1c7bb1cc2f0">isUpdateRound_</a> ()</td></tr>
<tr class="separator:a6cec153fbd1ca48bf092a1c7bb1cc2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704ef274657c05b52a6d1040ad8d6bb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a704ef274657c05b52a6d1040ad8d6bb7">seed_</a> (<a class="el" href="namespacenta.html#aa713df1be43bfaaa41b2736232cacbc9">UInt64</a> seed)</td></tr>
<tr class="memdesc:a704ef274657c05b52a6d1040ad8d6bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the random seed.  <a href="#a704ef274657c05b52a6d1040ad8d6bb7">More...</a><br /></td></tr>
<tr class="separator:a704ef274657c05b52a6d1040ad8d6bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605c1cca2f999f63ced2c2e3eb374d9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a605c1cca2f999f63ced2c2e3eb374d9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a605c1cca2f999f63ced2c2e3eb374d9e">printState</a> (vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;state)</td></tr>
<tr class="memdesc:a605c1cca2f999f63ced2c2e3eb374d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given UInt array in a nice format. <br /></td></tr>
<tr class="separator:a605c1cca2f999f63ced2c2e3eb374d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc397cc6d2bb01bfb977953947a75b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bc397cc6d2bb01bfb977953947a75b2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a2bc397cc6d2bb01bfb977953947a75b2">printState</a> (vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt; &amp;state)</td></tr>
<tr class="memdesc:a2bc397cc6d2bb01bfb977953947a75b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given Real array in a nice format. <br /></td></tr>
<tr class="separator:a2bc397cc6d2bb01bfb977953947a75b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a13b6dd070ffb80fadf80a4a72c18ca13"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html#a13b6dd070ffb80fadf80a4a72c18ca13">updateDutyCyclesHelper_</a> (vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt; &amp;dutyCycles, vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;newValues, <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> period)</td></tr>
<tr class="memdesc:a13b6dd070ffb80fadf80a4a72c18ca13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a duty cycle estimate with a new value.  <a href="#a13b6dd070ffb80fadf80a4a72c18ca13">More...</a><br /></td></tr>
<tr class="separator:a13b6dd070ffb80fadf80a4a72c18ca13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CLA spatial pooler implementation in C++. </p>
<h3>Description</h3>
<p>The Spatial Pooler is responsible for creating a sparse distributed representation of the input. Given an input it computes a set of sparse active columns and simultaneously updates its permanences, duty cycles, etc.</p>
<p>The primary public interfaces to this function are the "initialize" and "compute" methods.</p>
<p>Example usage: </p><pre class="fragment">SpatialPooler sp;
sp.initialize(inputDimensions, columnDimensions, &lt;parameters&gt;);
while (true) {
   &lt;get input vector&gt;
   sp.compute(inputVector, learn, activeColumns)
   &lt;do something with output&gt;
}</pre> 
<p>Definition at line <a class="el" href="_spatial_pooler_8hpp_source.html#l00067">67</a> of file <a class="el" href="_spatial_pooler_8hpp_source.html">SpatialPooler.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a183aba2789bfe50946739cdc38f5c89d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::adaptSynapses_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>inputVector</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>activeColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The primary method in charge of learning. </p>
<p>Adapts the permanence values of the synapses based on the input vector, and the chosen columns after inhibition round. Permanence values are increased for synapses connected to input bits that are turned on, and decreased for synapses connected to inputs bits that are turned off. </p><hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputVector</td><td>an int array of 0's and 1's that comprises the input to the spatial pooler. There exists an entry in the array for every input bit.</td></tr>
    <tr><td class="paramname">activeColumns</td><td>an int vector containing the indices of the columns that survived inhibition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d9e816078df4284842b8e2494676a3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::avgColumnsPerInput_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>REturns the average number of columns per input, taking into account the topology of the inputs and columns. </p>
<p>This value is used to calculate the inhibition radius. This function supports an arbitrary number of dimensions. If the number of column dimensions does not match the number of input dimensions, we treat the missing, or phantom dimensions as 'ones'.</p>
<dl class="section return"><dt>Returns</dt><dd>real number of the average number of columns per input. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1ee897199c24b56a1b0be1efca65aee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::avgConnectedSpanForColumn1D_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The range of connected synapses for column. </p>
<p>This is used to calculate the inhibition radius. This variation of the function only supports a 1 dimensional column toplogy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>An int number identifying a column in the permanence, potential and connectivity matrices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad93f11e2d4574ac31cc37051442aa91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::avgConnectedSpanForColumn2D_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The range of connectedSynapses per column, averaged for each dimension. </p>
<p>This vaule is used to calculate the inhibition radius. This variation of the function only supports a 2 dimensional column topology.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>An int number identifying a column in the permanence, potential and connectivity matrices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac30725e371ede94fc0c7c6d0170cf882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::avgConnectedSpanForColumnND_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The range of connectedSynapses per column, averaged for each dimension. </p>
<p>This vaule is used to calculate the inhibition radius. This variation of the function supports arbitrary column dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>An int number identifying a column in the permanence, potential and connectivity matrices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17cf440226ede079b927e5459ef58bb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::bumpUpWeakColumns_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method increases the permanence values of synapses of columns whose activity level has been too low. </p>
<p>Such columns are identified by having an overlap duty cycle that drops too much below those of their peers. The permanence values for such columns are increased. </p>

</div>
</div>
<a class="anchor" id="a8b8c8623a959e1afb557435218d6b650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::calculateOverlap_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>inputVector</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function determines each column's overlap with the current input vector. </p>
<p>The overlap of a column is the number of synapses for that column that are connected (permance value is greater than '_synPermConnected') to input bits which are turned on. Overlap values that are lower than the 'stimulusThreshold' are ignored. The implementation takes advantage of the SpraseBinaryMatrix class to perform this calculation efficiently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputVector</td><td>a int array of 0's and 1's that comprises the input to the spatial pooler.</td></tr>
    <tr><td class="paramname">overlap</td><td>an int vector containing the overlap score for each column. The overlap score for a column is defined as the number of synapses in a "connected state" (connected synapses) that are connected to input bits which are turned on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4f905c3b405015a22c8b369b78918e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nta::algorithms::spatial_pooler::SpatialPooler::compute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>inputVector</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>learn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>activeVector</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stripNeverLearned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the main workshorse method of the <a class="el" href="classnta_1_1algorithms_1_1spatial__pooler_1_1_spatial_pooler.html" title="CLA spatial pooler implementation in C++. ">SpatialPooler</a> class. </p>
<p>This method takes an input vector and computes the set of output active columns. If 'learn' is set to True, this method also performs learning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputVector</td><td>An array of integer 0's and 1's that comprises the input to the spatial pooler. The length of the array must match the total number of input bits implied by the constructor (also returned by the method getNumInputs). In cases where the input is multi-dimensional, inputVector is a flattened array of inputs.</td></tr>
    <tr><td class="paramname">learn</td><td>A boolean value indicating whether learning should be performed. Learning entails updating the permanence values of the synapses, duty cycles, etc. Learning is typically on but setting learning to 'off' is useful for analyzing the current state of the SP. For example, you might want to feed in various inputs and examine the resulting SDR's. Note that if learning is off, boosting is turned off and columns that have never won will be removed from activeVector. TODO: we may want to keep boosting on even when learning is off.</td></tr>
    <tr><td class="paramname">activeVector</td><td>An array representing the winning columns after inhinition. The size of the array is equal to the number of columns (also returned by the method getNumColumns). This array will be populated with 1's at the indices of the active columns, and 0's everywhere else. In the case where the output is multi-dimensional, activeVector represents a flattened array of outputs.</td></tr>
    <tr><td class="paramname">stripNeverLearned</td><td>A boolean value indicating when to strip columns from the predictions if they have never learned. The default behavior is to strip unlearned columns but this should be disabled when using a random, unlearned spatial pooler. NOTE: if you rely on this behavior then you should additionally call the stripNeverLearned method directly on the activeVector output as we will be changing the default to false and then removing this parameter entirely in the near future. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1576b0089512d735a7296f83e30dc49b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getActiveDutyCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>activeDutyCycles</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the activity duty cycles for all columns. </p>
<p>'activeDutyCycles' size must match the number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">activeDutyCycles</td><td>real array to store activity duty cycles for all columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07be4b1f4e09bc9a61357358695632c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getBoostFactors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>boostFactors</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the boost factors for all columns. </p>
<p>'boostFactors' size must match the number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boostFactors</td><td>real array to store boost factors of all columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16ed4e9527e2429cb180903c45184a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&gt; nta::algorithms::spatial_pooler::SpatialPooler::getColumnDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dimensions of the columns in the region. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer number of column dimension. </dd></dl>

</div>
</div>
<a class="anchor" id="ad033bde8fbab993a87186aaeb1b54709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getConnectedCounts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>connectedCounts</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of connected synapses for all columns. </p>
<p>'connectedCounts' size must match the number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connectedCounts</td><td>integer array to store the connected synapses for all columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56781059bc62f8c39049a767f69106e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getConnectedSynapses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>connectedSynapses</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the connected synapses for a given column. </p>
<p>'connectedSynapses' size must match the number of inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>integer of column index.</td></tr>
    <tr><td class="paramname">connectedSynapses</td><td>integer array to store the connected synapses for a given column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4083bd522642559c93e3e1996dfd688f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::getDutyCyclePeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the duty cycle period. </p>
<dl class="section return"><dt>Returns</dt><dd>integer of duty cycle period. </dd></dl>

</div>
</div>
<a class="anchor" id="acbec6b93518ee58ee842cc6ab70e835d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nta::algorithms::spatial_pooler::SpatialPooler::getGlobalInhibition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>boolen value of whether global inhibition is enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a77e95b342ec37a893b62920044f89100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::getInhibitionRadius </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inhibition radius. </p>
<dl class="section return"><dt>Returns</dt><dd>(positive) integer of inhibition radius/ </dd></dl>

</div>
</div>
<a class="anchor" id="a5472e7012ba87d87a30bd8e1b2fa856a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&gt; nta::algorithms::spatial_pooler::SpatialPooler::getInputDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dimensions of the input vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer vector of input dimension. </dd></dl>

</div>
</div>
<a class="anchor" id="a80b505840b6bd081dca77956f1c82a0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::getIterationLearnNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the learning iteration number. </p>
<dl class="section return"><dt>Returns</dt><dd>integer of the learning iteration number. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c7b28e372d13489f6f6abb93918843a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::getIterationNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the iteration number. </p>
<dl class="section return"><dt>Returns</dt><dd>integer number of iteration number. </dd></dl>

</div>
</div>
<a class="anchor" id="a87b8f0c423c18752049ed0454d49003e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::getLocalAreaDensity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the local area density. </p>
<p>Returns a value less than 0 if parameter is unused".</p>
<dl class="section return"><dt>Returns</dt><dd>real number of local area density. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5c2ace266a56af74dacdbe9b94576e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::getMaxBoost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum boost value. </p>
<dl class="section return"><dt>Returns</dt><dd>real number of the maximum boost value. </dd></dl>

</div>
</div>
<a class="anchor" id="afcf43a72aff541e81e9d39ea2cf18b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getMinActiveDutyCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>minActiveDutyCycles</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum activity duty cycles for all columns. </p>
<p>'_minActiveDutyCycles' size must match the number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minActiveDutyCycles</td><td>real array to store the minimum activity duty cycles for all columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10236285f9a464ce4ba11f1f066d66b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getMinOverlapDutyCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>minOverlapDutyCycles</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum overlap duty cycles for all columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minOverlapDutyCycles</td><td>real arry to store mininum overlap duty cycles for all columns. 'minOverlapDutyCycles' size must match the number of columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0add71fe208929254ea753d5f42be6ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::getMinPctActiveDutyCycles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum tolerated activity duty cycle, given as percent of neighbors' activity duty cycle. </p>
<dl class="section return"><dt>Returns</dt><dd>minPctOverlapDutyCycles real number of the minimum tolerated activity duty cycle. </dd></dl>

</div>
</div>
<a class="anchor" id="a60a9a4d472dbbb130848b25f43e9c085"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::getMinPctOverlapDutyCycles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum tolerated overlaps, given as percent of neighbors overlap score. </p>
<dl class="section return"><dt>Returns</dt><dd>real number of the minimum tolerated overlaps. </dd></dl>

</div>
</div>
<a class="anchor" id="aad6503822b4ea9739917ac71858c5634"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getNeighbors1D_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wrapAround</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of indices corresponding to the neighbors of a given column. </p>
<p>In this variation of the method, which only supports a one dimensional column toplogy, a column's neighbors are those neighbors who are 'radius' indices away. This information is needed to perform inhibition. This method is a subset of _getNeighborsND and is only included for illustration purposes, and potentially enhanced performance for spatial pooler implementations that only require a one-dimensional topology. </p><hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>An integer number. The index identifying a column in the permanence, potential and connectivity matrices.</td></tr>
    <tr><td class="paramname">dimensions</td><td>An int array containg a dimensions for the column space. A 2x3 grid will be represented by [2,3].</td></tr>
    <tr><td class="paramname">radius</td><td>An integer number Indicates how far away from a given column are other columns to be considered its neighbors. In the previous 2x3 example, each column with coordinates: [2+/-radius, 3+/-radius] is considered a neighbor.</td></tr>
    <tr><td class="paramname">wrapAround</td><td>A boolean value indicating whether to consider columns at the border of a dimensions to be adjacent to columns at the other end of the dimension. For example, if the columns are layed out in one deimnsion, columns 1 and 10 will be considered adjacent if wrapAround is set to true: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].</td></tr>
    <tr><td class="paramname">neighbors</td><td>An int arrayof indices corresponding to the neighbors of a given column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0daf69fbe52b34f44d78b0a5671485de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getNeighbors2D_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wrapAround</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of indices corresponding to the neighbors of a given column. </p>
<p>Since the permanence values are stored in such a way that information about toplogy is lost, this method allows for reconstructing the toplogy of the inputs, which are flattened to one array. Given a column's index, its neighbors are defined as those columns that are 'radius' indices away from it in each dimension. The method returns a list of the flat indices of these columns. This method is a subset of _getNeighborsND and is only included for illustration purposes, and potentially enhanced performance for spatial pooler implementations that only require a two-dimensional topology.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>An integer number. The index identifying a column in the permanence, potential and connectivity matrices.</td></tr>
    <tr><td class="paramname">dimensions</td><td>An int array containg a dimensions for the column space. A 2x3 grid will be represented by [2,3].</td></tr>
    <tr><td class="paramname">radius</td><td>An integer number Indicates how far away from a given column are other columns to be considered its neighbors. In the previous 2x3 example, each column with coordinates: [2+/-radius, 3+/-radius] is considered a neighbor.</td></tr>
    <tr><td class="paramname">wrapAround</td><td>A boolean value indicating whether to consider columns at the border of a dimensions to be adjacent to columns at the other end of the dimension. For example, if the columns are layed out in one deimnsion, columns 1 and 10 will be considered adjacent if wrapAround is set to true: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].</td></tr>
    <tr><td class="paramname">neighbors</td><td>An int array of indices corresponding to the neighbors of a given column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bbd6eacd41dbf5b626505aa385447ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getNeighborsND_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wrapAround</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to _getNeighbors1D and _getNeighbors2D, this function returns a list of indices corresponding to the neighbors of a given column. </p>
<p>Since the permanence values are stored in such a way that information about toplogy is lost. This method allows for reconstructing the toplogy of the inputs, which are flattened to one array. Given a column's index, its neighbors are defined as those columns that are 'radius' indices away from it in each dimension. The method returns a list of the flat indices of these columns. </p><hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>An integer number. The index identifying a column in the permanence, potential and connectivity matrices.</td></tr>
    <tr><td class="paramname">dimensions</td><td>An int array containg a dimensions for the column space. A 2x3 grid will be represented by [2,3].</td></tr>
    <tr><td class="paramname">radius</td><td>An integer number Indicates how far away from a given column are other columns to be considered its neighbors. In the previous 2x3 example, each column with coordinates: [2+/-radius, 3+/-radius] is considered a neighbor.</td></tr>
    <tr><td class="paramname">wrapAround</td><td>A boolean value indicating whether to consider columns at the border of a dimensions to be adjacent to columns at the other end of the dimension. For example, if the columns are layed out in one deimnsion, columns 1 and 10 will be considered adjacent if wrapAround is set to true: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].</td></tr>
    <tr><td class="paramname">neighbors</td><td>An int arrayof indices corresponding to the neighbors of a given column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95df3b49f5857465664e8fd2b5296346"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a17d4a8b25826d8927b44cdbb41109e1b">Int</a> nta::algorithms::spatial_pooler::SpatialPooler::getNumActiveColumnsPerInhArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of active columns per inhibition area. </p>
<dl class="section return"><dt>Returns</dt><dd>integer number of active columns per inhbition area, Returns a value less than 0 if parameter is unuse. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4b1c595c5f7067a5e5e5b0eefc97bdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::getNumColumns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of columns. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer number of column numbers. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4c864a382247364d0d000f1aaae09c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::getNumInputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of inputs. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer number of inputs. </dd></dl>

</div>
</div>
<a class="anchor" id="a862764b9a281e62e3d06ca9e4eee9ae1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getOverlapDutyCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>overlapDutyCycles</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the overlap duty cycles for all columns. </p>
<p>'overlapDutyCycles' size must match the number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlapDutyCycles</td><td>real array to store overlap duty cycles for all columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6847e121ebde30d7107781449e47f4a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getPermanence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>permanence</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the permanence values for a given column. </p>
<p>'permanence' size must match the number of inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>integer of column index.</td></tr>
    <tr><td class="paramname">permanence</td><td>real array to store permanence values for the selected column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9015b431ceb397dc770082af900a3d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::getPotential </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>potential</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the potential mapping for a given column. </p>
<p>'potential' size must match the number of inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>integer of column index.</td></tr>
    <tr><td class="paramname">potential</td><td>integer array of potential mapping for the selected column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a958bd73def7bb439beaae088bdf4ea92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::getPotentialPct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the potential percent. </p>
<dl class="section return"><dt>Returns</dt><dd>real number of the potential percent. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ed5186a1f30973520b5accef40cf50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::getPotentialRadius </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the potential radius. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer number of potential radius. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cd576b3ee777208c8a81175671c7219"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::getSpVerbosity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the verbosity level. </p>
<dl class="section return"><dt>Returns</dt><dd>integer of the verbosity level. </dd></dl>

</div>
</div>
<a class="anchor" id="a2711ea6540528a488dab276cd081ef1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::getStimulusThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the stimulus threshold. </p>
<dl class="section return"><dt>Returns</dt><dd>integer number of stimulus threshold. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b4f549c6239cfa0dd3a7f460e4cfbfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::getSynPermActiveInc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the permanence increment amount for active synapses inputs. </p>
<dl class="section return"><dt>Returns</dt><dd>real number of the permanence increment amount for active synapses inputs. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e52ad8321b4e1b5cbfa56c29d8cabae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::getSynPermBelowStimulusInc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the permanence increment amount for columns that have not been recently active. </p>
<dl class="section return"><dt>Returns</dt><dd>positive real number of the permanence increment amount for columns that have not been recently active. </dd></dl>

</div>
</div>
<a class="anchor" id="a141cd132a0d1f4d9dacd24162f67c213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::getSynPermConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the permanence amount that qualifies a synapse as being connected. </p>
<dl class="section return"><dt>Returns</dt><dd>real number of the permanence amount that qualifies a synapse as being connected. </dd></dl>

</div>
</div>
<a class="anchor" id="af94ce7edfb7d918c20ef3995739ca932"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::getSynPermInactiveDec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the permanence decrement amount for inactive synapses. </p>
<dl class="section return"><dt>Returns</dt><dd>real number of the permanence decrement amount for inactive synapses. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6d28bbb4d4c79370ea53923a99265a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::getSynPermTrimThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the permanence trim threshold. </p>
<dl class="section return"><dt>Returns</dt><dd>real number of the permanence trim threshold. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e744be6cfdb423505098a1c6c69e313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::getUpdatePeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the update period. </p>
<dl class="section return"><dt>Returns</dt><dd>integer of update period. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dc35eb29a2b307f057151753ce9800f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nta::algorithms::spatial_pooler::SpatialPooler::getWrapAround </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns boolean value of wrapAround which indicates if receptive fields should wrap around from the beginning the input dimensions to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>the boolean value of wrapAround. </dd></dl>

</div>
</div>
<a class="anchor" id="ac822ec730fac5fcfc6fec441da2630b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::inhibitColumns_ </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>activeColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs inhibition. </p>
<p>This method calculates the necessary values needed to actually perform inhibition and then delegates the task of picking the active columns to helper functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlaps</td><td>an array containing the overlap score for each column. The overlap score for a column is defined as the number of synapses in a "connected state" (connected synapses) that are connected to input bits which are turned on.</td></tr>
    <tr><td class="paramname">activeColumns</td><td>an int array containing the indices of the active columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a756561560cb4d74617e992b61bf0f902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::inhibitColumnsGlobal_ </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>activeColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform global inhibition. </p>
<p>Performing global inhibition entails picking the top 'numActive' columns with the highest overlap score in the entire region. At most half of the columns in a local neighborhood are allowed to be active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlaps</td><td>a real array containing the overlap score for each column. The overlap score for a column is defined as the number of synapses in a "connected state" (connected synapses) that are connected to input bits which are turned on.</td></tr>
    <tr><td class="paramname">density</td><td>a real number of the fraction of columns to survive inhibition.</td></tr>
    <tr><td class="paramname">activeColumns</td><td>an int array containing the indices of the active columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afad48983bb2fe2d0968684f18ef3bacd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::inhibitColumnsLocal_ </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>activeColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs local inhibition. </p>
<p>Local inhibition is performed on a column by column basis. Each column observes the overlaps of its neighbors and is selected if its overlap score is within the top 'numActive' in its local neighborhood. At most half of the columns in a local neighborhood are allowed to be active. </p><hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlaps</td><td>an array containing the overlap score for each column. The overlap score for a column is defined as the number of synapses in a "connected state" (connected synapses) that are connected to input bits which are turned on.</td></tr>
    <tr><td class="paramname">density</td><td>The fraction of columns to survive inhibition. This value is only an intended target. Since the surviving columns are picked in a local fashion, the exact fraction of survining columns is likely to vary.</td></tr>
    <tr><td class="paramname">activeColumns</td><td>an int array containing the indices of the active columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d3e0888ccb36dbdc77bf8758f97e351"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nta::algorithms::spatial_pooler::SpatialPooler::initialize </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt;&#160;</td>
          <td class="paramname"><em>inputDimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt;&#160;</td>
          <td class="paramname"><em>columnDimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>potentialRadius</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>potentialPct</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>globalInhibition</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>localAreaDensity</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>numActiveColumnsPerInhArea</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>stimulusThreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>synPermInactiveDec</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>synPermActiveInc</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>synPermConnected</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>minPctOverlapDutyCycles</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>minPctActiveDutyCycles</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>dutyCyclePeriod</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>maxBoost</em> = <code>10.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a17d4a8b25826d8927b44cdbb41109e1b">Int</a>&#160;</td>
          <td class="paramname"><em>seed</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>spVerbosity</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wrapAround</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the spatial pooler using the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputDimensions</td><td>A list of integers representing the dimensions of the input vector. Format is [height, width, depth, ...], where each value represents the size of the dimension. For a topology of one dimesion with 100 inputs use [100]. For a two dimensional topology of 10x5 use [10,5].</td></tr>
    <tr><td class="paramname">columnDimensions</td><td>A list of integers representing the dimensions of the columns in the region. Format is [height, width, depth, ...], where each value represents the size of the dimension. For a topology of one dimesion with 2000 columns use 2000, or [2000]. For a three dimensional topology of 32x64x16 use [32, 64, 16].</td></tr>
    <tr><td class="paramname">potentialRadius</td><td>This parameter deteremines the extent of the input that each column can potentially be connected to. This can be thought of as the input bits that are visible to each column, or a 'receptive field' of the field of vision. A large enough value will result in global coverage, meaning that each column can potentially be connected to every input bit. This parameter defines a square (or hyper square) area: a column will have a max square potential pool with sides of length (2 * potentialRadius + 1).</td></tr>
    <tr><td class="paramname">potentialPct</td><td>The percent of the inputs, within a column's potential radius, that a column can be connected to. If set to 1, the column will be connected to every input within its potential radius. This parameter is used to give each column a unique potential pool when a large potentialRadius causes overlap between the columns. At initialization time we choose ((2*potentialRadius + 1)^(# inputDimensions) * potentialPct) input bits to comprise the column's potential pool.</td></tr>
    <tr><td class="paramname">globalInhibition</td><td>If true, then during inhibition phase the winning columns are selected as the most active columns from the region as a whole. Otherwise, the winning columns are selected with resepct to their local neighborhoods. Global inhibition boosts performance significantly but there is no topology at the output.</td></tr>
    <tr><td class="paramname">localAreaDensity</td><td>The desired density of active columns within a local inhibition area (the size of which is set by the internally calculated inhibitionRadius, which is in turn determined from the average size of the connected potential pools of all columns). The inhibition logic will insure that at most N columns remain ON within a local inhibition area, where N = localAreaDensity * (total number of columns in inhibition area). If localAreaDensity is set to a negative value output sparsity will be determined by the numActivePerInhArea.</td></tr>
    <tr><td class="paramname">numActiveColumnsPerInhArea</td><td>An alternate way to control the sparsity of active columns. If numActivePerInhArea is specified then localAreaDensity must be less than 0, and vice versa. When numActivePerInhArea &gt; 0, the inhibition logic will insure that at most 'numActivePerInhArea' columns remain ON within a local inhibition area (the size of which is set by the internally calculated inhibitionRadius). When using this method, as columns learn and grow their effective receptive fields, the inhibitionRadius will grow, and hence the net density of the active columns will <em>decrease</em>. This is in contrast to the localAreaDensity method, which keeps the density of active columns the same regardless of the size of their receptive fields.</td></tr>
    <tr><td class="paramname">stimulusThreshold</td><td>This is a number specifying the minimum number of synapses that must be active in order for a column to turn ON. The purpose of this is to prevent noisy input from activating columns.</td></tr>
    <tr><td class="paramname">synPermInactiveDec</td><td>The amount by which the permanence of an inactive synapse is decremented in each learning step.</td></tr>
    <tr><td class="paramname">synPermActiveInc</td><td>The amount by which the permanence of an active synapse is incremented in each round.</td></tr>
    <tr><td class="paramname">synPermConnected</td><td>The default connected threshold. Any synapse whose permanence value is above the connected threshold is a "connected synapse", meaning it can contribute to the cell's firing.</td></tr>
    <tr><td class="paramname">minPctOverlapDutyCycles</td><td>A number between 0 and 1.0, used to set a floor on how often a column should have at least stimulusThreshold active inputs. Periodically, each column looks at the overlap duty cycle of all other column within its inhibition radius and sets its own internal minimal acceptable duty cycle to: minPctDutyCycleBeforeInh * max(other columns' duty cycles). On each iteration, any column whose overlap duty cycle falls below this computed value will get all of its permanence values boosted up by synPermActiveInc. Raising all permanences in response to a sub-par duty cycle before inhibition allows a cell to search for new inputs when either its previously learned inputs are no longer ever active, or when the vast majority of them have been "hijacked" by other columns.</td></tr>
    <tr><td class="paramname">minPctActiveDutyCycles</td><td>A number between 0 and 1.0, used to set a floor on how often a column should be activate. Periodically, each column looks at the activity duty cycle of all other columns within its inhibition radius and sets its own internal minimal acceptable duty cycle to: <pre class="fragment">minPctDutyCycleAfterInh * max(other columns' duty cycles).
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>On each iteration, any column whose duty cycle after inhibition falls below this computed value will get its internal boost factor increased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dutyCyclePeriod</td><td>The period used to calculate duty cycles. Higher values make it take longer to respond to changes in boost. Shorter values make it potentially more unstable and likely to oscillate.</td></tr>
    <tr><td class="paramname">maxBoost</td><td>The maximum overlap boost factor. Each column's overlap gets multiplied by a boost factor before it gets considered for inhibition. The actual boost factor for a column is a number between 1.0 and maxBoost. A boost factor of 1.0 is used if the duty cycle is &gt;= minOverlapDutyCycle, maxBoost is used if the duty cycle is 0, and any duty cycle in between is linearly extrapolated from these 2 endpoints.</td></tr>
    <tr><td class="paramname">seed</td><td>Seed for our random number generator. If seed is &lt; 0 a randomly generated seed is used. The behavior of the spatial pooler is deterministic once the seed is set.</td></tr>
    <tr><td class="paramname">spVerbosity</td><td>spVerbosity level: 0, 1, 2, or 3</td></tr>
    <tr><td class="paramname">wrapAround</td><td>boolean value that determines whether or not inputs at the beginning and end of an input dimension are considered neighbors for the purpose of mapping inputs to columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4039e5a6f225e436217d1cadf5eb307a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&gt; nta::algorithms::spatial_pooler::SpatialPooler::initPermanence_ </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>potential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>connectedPct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the permanences of a column. </p>
<p>The method returns a 1-D array the size of the input, where each entry in the array represents the initial permanence value between the input bit at the particular index in the array, and the column represented by the 'index' parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">potential</td><td>A int vector specifying the potential pool of the column. Permanence values will only be generated for input bits</td></tr>
  </table>
  </dd>
</dl>
<p>corresponding to indices for which the mask value is 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connectedPct</td><td>A real value between 0 or 1 specifying the percent of the input bits that will start off in a connected state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a81771becb1fe3e37b0bf1c3ec7b879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::initPermConnected_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a randomly generated permanence value for a synapses that is initialized in a connected state. </p>
<p>The basic idea here is to initialize permanence values very close to synPermConnected so that a small number of learning steps could make it disconnected or connected.</p>
<p>Note: experimentation was done a long time ago on the best way to initialize permanence values, but the history for this particular scheme has been lost.</p>
<dl class="section return"><dt>Returns</dt><dd>real number of a randomly generated permanence value for a synapses that is initialized in a connected state. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2cd62c4aeac1fd463db337a4830d56d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> nta::algorithms::spatial_pooler::SpatialPooler::initPermNonConnected_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a randomly generated permanence value for a synapses that is to be initialized in a non-connected state. </p>
<dl class="section return"><dt>Returns</dt><dd>real number of a randomly generated permanence value for a synapses that is to be initialized in a non-connected state. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cec153fbd1ca48bf092a1c7bb1cc2f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nta::algorithms::spatial_pooler::SpatialPooler::isUpdateRound_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>boolean value indicating whether enough rounds have passed to warrant updates of duty cycles </dd></dl>

</div>
</div>
<a class="anchor" id="a4fb5369451cb903ac58a4aa3944fd355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nta::algorithms::spatial_pooler::SpatialPooler::load </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>inStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load (deserialize) and initialize the spatial pooler from the specified input stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inStream</td><td>A valid istream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08fed3797d6c30b898b9a798bb70094d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::mapColumn_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a column to its respective input index, keeping to the topology of the region. </p>
<p>It takes the index of the column as an argument and determines what is the index of the flattened input vector that is to be the center of the column's potential pool. It distributes the columns over the inputs uniformly. The return value is an integer representing the index of the input bit. Examples of the expected output of this method: If the topology is one dimensional, and the column index is 0, this method will return the input index 0. If the column index is 1, and there are 3 columns over 7 inputs, this method will return the input index 3. If the topology is two dimensional, with column dimensions [3, 5] and input dimensions [7, 11], and the column index is 3, the method returns input index 8. </p><hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index identifying a column in the permanence, potential and connectivity matrices. </td></tr>
    <tr><td class="paramname">wrapAround</td><td>A boolean value indicating that boundaries should be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abde1873c29f01b04ce7ae65aaf604142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&gt; nta::algorithms::spatial_pooler::SpatialPooler::mapPotential_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wrapAround</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a column to its input bits. </p>
<p>This method encapsultes the topology of the region. It takes the index of the column as an argument and determines what are the indices of the input vector that are located within the column's potential pool. The return value is a list containing the indices of the input bits. The current implementation of the base class only supports a 1 dimensional topology of columsn with a 1 dimensional topology of inputs. To extend this class to support 2-D topology you will need to override this method. Examples of the expected output of this method: If the potentialRadius is greater than or equal to the entire input space, (global visibility), then this method returns an array filled with all the indices If the topology is one dimensional, and the potentialRadius is 5, this method will return an array containing 5 consecutive values centered on the index of the column (wrapping around if necessary). If the topology is two dimensional (not implemented), and the potentialRadius is 5, the method should return an array containing 25 '1's, where the exact indices are to be determined by the mapping from 1-D index to 2-D position. </p><hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>An int index identifying a column in the permanence, potential and connectivity matrices.</td></tr>
    <tr><td class="paramname">wrapAround</td><td>A boolean value indicating that boundaries should be region boundaries ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a317122c03fbfbe47ed0adc6ed99dfd80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::persistentSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes that a save operation would result in. </p>
<p>Note: this method is currently somewhat inefficient as it just does a full save into an ostream and counts the resulting size.</p>
<dl class="section return"><dt>Returns</dt><dd>Integer number of bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a83aa964fa6465e4cd5c11160c602b1df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nta::algorithms::spatial_pooler::SpatialPooler::save </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>outStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save (serialize) the current state of the spatial pooler to the specified output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outStream</td><td>A valid ostream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a704ef274657c05b52a6d1040ad8d6bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::seed_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#aa713df1be43bfaaa41b2736232cacbc9">UInt64</a>&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the random seed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>64bit int of random seed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02e57c2e38675a8f635ed34f49afcf2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setActiveDutyCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>activeDutyCycles</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the activity duty cycles for all columns. </p>
<p>'activeDutyCycles' size must match the number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">activeDutyCycles</td><td>real array of the activity duty cycles for all columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a495a44ea6eca04fb8f7f9c3ebd02ecb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setBoostFactors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>boostFactors</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the boost factors for all columns. </p>
<p>'boostFactors' size must match the number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boostFactors</td><td>real array of boost factors of all columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafdff66851e1e95e822550a3c5de66ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setDutyCyclePeriod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>dutyCyclePeriod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the duty cycle period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dutyCyclePeriod</td><td>integer number of duty cycle period. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60e65e3eed0dea2e49e1a764fb6b7447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setGlobalInhibition </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>globalInhibition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets global inhibition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalInhibition</td><td>boolen varable of whether global inhibition is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a21cc4a6691ed8f56568d00c3d8b8b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setInhibitionRadius </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>inhibitionRadius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the inhibition radius. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inhibitionRadius</td><td>integer of inhibition radius. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa4b54df2652c7bf7a35c47bbd8ac054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setIterationLearnNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>iterationLearnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the learning iteration number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterationLearnNum</td><td>integer of learning iteration number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a821fc1673bf265bc26c92d98d63dbf6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setIterationNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>iterationNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the iteration number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterationNum</td><td>integer number of iteration number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e54ace021693e60e7f1eca46ada520e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setLocalAreaDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>localAreaDensity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the local area density. </p>
<p>Invalidates the 'numActivePerInhArea' parameter".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localAreaDensity</td><td>real number of local area density. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac335d159fa336f187f4da46174136daa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setMaxBoost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>maxBoost</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum boost value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxBoost</td><td>real number of maximum boost value, must be larger than 1.0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47bb97ad7efcf05c220ea027e01e766e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setMinActiveDutyCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>minActiveDutyCycles</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the minimum activity duty cycles for all columns. </p>
<p>'_minActiveDutyCycles' size must match the number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minActiveDutyCycles</td><td>real array of the minimum activity duty cycles for all columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6d0d7289827535a4b5f4bfc86d39ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setMinOverlapDutyCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>minOverlapDutyCycles</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the minimum overlap duty cycles for all columns. </p>
<p>'_minOverlapDutyCycles' size must match the number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minOverlapDutyCycles</td><td>real array of the minimum overlap duty cycles for all columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a952ef18d7eea8b2054c5807c9e0cb3de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setMinPctActiveDutyCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>minPctActiveDutyCycles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the minimum tolerated activity duty cycle, given as percent of neighbors' activity duty cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minPctActiveDutyCycles</td><td>real number of the minimum tolerated activity duty cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab26b6d644cb0fadc6655bdee6e7494f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setMinPctOverlapDutyCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>minPctOverlapDutyCycles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the minimum tolerated overlaps, given as percent of neighbors overlap score. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minPctOverlapDutyCycles</td><td>real number of the minimum tolerated overlaps. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa81539a2ddd697ed84aff64cae980b61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setNumActiveColumnsPerInhArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>numActiveColumnsPerInhArea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of active columns per inhibition area. </p>
<p>Invalidates the 'localAreaDensity' parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numActiveColumnsPerInhArea</td><td>integer number of active columns per inhibition area. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa655081fba2fd54e16639b16377de46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setOverlapDutyCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>overlapDutyCycles</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the overlap duty cycles for all columns. </p>
<p>'overlapDutyCycles' size must match the number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlapDutyCycles</td><td>real array of the overlap duty cycles for all columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace58dd7de19a87fc4587591c89729ebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setPermanence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>permanence</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the permanence values for a given column. </p>
<p>'permanence' size must match the number of inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>integer of column index.</td></tr>
    <tr><td class="paramname">permanence</td><td>real array of permanence values for the selected column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a372eae71c4fd5d9ffe9c0f8de3e02f02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setPotential </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>potential</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the potential mapping for a given column. </p>
<p>'potential' size must match the number of inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>integer of column index.</td></tr>
    <tr><td class="paramname">potential</td><td>integer array of potential mapping for the selected column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa27f183609145489f9c78b7b9ba6e0c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setPotentialPct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>potentialPct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the potential percent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">potentialPct</td><td>real number of potential percent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59cdd2e79511f169be0c227dc17b843e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setPotentialRadius </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>potentialRadius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the potential radius. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">potentialRadius</td><td>integer number of potential raduis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a487656f51db4fd4bcca4ad1d7f26b273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setSpVerbosity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>spVerbosity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the verbosity level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spVerbosity</td><td>integer of verbosity level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb1e7663b5fb482a3e1eb61de8bd23ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setStimulusThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>stimulusThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the stimulus threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stimulusThreshold</td><td>(positive) integer number of stimulus threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2eb386453b2bf1b3a0a3d9375fff7744"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setSynPermActiveInc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>synPermActiveInc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the permanence increment amount for active synapses inputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synPermActiveInc</td><td>real number of the permanence increment amount for active synapses inputs, must be &gt;0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4cda4776232272530abb308fa33c9ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setSynPermBelowStimulusInc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>synPermBelowStimulusInc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the permanence increment amount for columns that have not been recently active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synPermBelowStimulusInc</td><td>real number of the permanence increment amount for columns that have not been recently active, must be larger than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27f808284a8e8372942289d942d25004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setSynPermConnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>setSynPermConnected</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the permanence amount that qualifies a synapse as being connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setSynPermConnected</td><td>real number of the permanence amount that qualifies a synapse as being connected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4458331f6ee8724fc8e61c07ee1feacc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setSynPermInactiveDec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>synPermInactiveDec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the permanence decrement amount for inactive synapses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synPermInactiveDec</td><td>real number of the permanence decrement amount for inactive synapses. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8106a472483d40338be176e58c40c98f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setSynPermTrimThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a>&#160;</td>
          <td class="paramname"><em>synPermTrimThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the permanence trim threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synPermTrimThreshold</td><td>real number of the permanence trim threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad91eabb8c79b4f0d072153f5c4d9baec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setUpdatePeriod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>updatePeriod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the update period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updatePeriod</td><td>integer of update period. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab746d72ed9619fe75d83be75eeca224d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::setWrapAround </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wrapAround</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets wrapAround. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wrapAround</td><td>boolean value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacc0cbb92811f66597595db76838aef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::stripUnlearnedColumns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>activeArray</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the set of columns who have never been active from the set of active columns selected in the inhibition round. </p>
<p>Such columns cannot represent learned pattern and are therefore meaningless if only inference is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">activeArray</td><td>An int array containing the indices of the active columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8deb32d2838ef8426f0d6365c40cd3b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::updateBookeepingVars_ </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>learn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates counter instance variables each round. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">learn</td><td>a boolean value indicating whether learning should be performed. Learning entails updating the permanence values of the synapses, and hence modifying the 'state' of the model. setting learning to 'off' might be useful for indicating separate training vs. testing sets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3664cfdfc194e59d8f4d05942534aabf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::updateBoostFactors_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the boost factors for all columns. </p>
<p>The boost factors are used to increase the overlap of inactive columns to improve their chances of becoming active. and hence encourage participation of more columns in the learning process. This is a line defined as: y = mx + b boost = (1-maxBoost)/minDuty * dutyCycle + maxFiringBoost. Intuitively this means that columns that have been active enough have a boost factor of 1, meaning their overlap is not boosted. Columns whose active duty cycle drops too much below that of their neighbors are boosted depending on how infrequently they have been active. The more infrequent, the more they are boosted. The exact boost factor is linearly interpolated between the points (dutyCycle:0, boost:maxFiringBoost) and (dutyCycle:minDuty, boost:1.0). </p><pre class="fragment">        boostFactor
            ^
maxBoost _  |
            |\
            | \
      1  _  |  \ _ _ _ _ _ _ _
            |
            +--------------------&gt; activeDutyCycle
               |
        minActiveDutyCycle
</pre> 
</div>
</div>
<a class="anchor" id="a8ccaea276c025b6a2c894c65ec395db3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::updateDutyCycles_ </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>activeArray</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the duty cycles for each column. </p>
<p>The OVERLAP duty cycle is a moving average of the number of inputs which overlapped with the each column. The ACTIVITY duty cycles is a moving average of the frequency of activation for each column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlaps</td><td>an int vector containing the overlap score for each column. The overlap score for a column is defined as the number of synapses in a "connected state" (connected synapses) that are connected to input bits which are turned on.</td></tr>
    <tr><td class="paramname">activeArray</td><td>An int array containing the indices of the active columns, the sprase set of columns which survived inhibition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13b6dd070ffb80fadf80a4a72c18ca13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nta::algorithms::spatial_pooler::SpatialPooler::updateDutyCyclesHelper_ </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dutyCycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates a duty cycle estimate with a new value. </p>
<p>This is a helper function that is used to update several duty cycle variables in the Column class, such as: overlapDutyCucle, activeDutyCycle, minPctDutyCycleBeforeInh, minPctDutyCycleAfterInh, etc. returns the updated duty cycle. Duty cycles are updated according to the following formula: </p><pre class="fragment">              (period - 1)*dutyCycle + newValue
  dutyCycle := ----------------------------------
                          period
</pre> <hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dutyCycles</td><td>A real array containing one or more duty cycle values that need to be updated.</td></tr>
    <tr><td class="paramname">newValues</td><td>A int vector used to update the duty cycle.</td></tr>
    <tr><td class="paramname">period</td><td>A int number indicating the period of the duty cycle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0777f2ceee25e1cdded45cca79374a57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::updateInhibitionRadius_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the inhibition radius. </p>
<p>The inhibition radius is a meausre of the square (or hypersquare) of columns that each a column is "conencted to" on average. Since columns are not connected to each other directly, we determine this quantity by first figuring out how many <em>inputs</em> a column is connected to, and then multiplying it by the total number of columns that exist for each input. For multiple dimension the aforementioned calculations are averaged over all dimensions of inputs and columns. This value is meaningless if global inhibition is enabled. </p>

</div>
</div>
<a class="anchor" id="aa95f902fd98059835d8ac43110c1cc31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::updateMinDutyCycles_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the minimum duty cycles defining normal activity for a column. </p>
<p>A column with activity duty cycle below this minimum threshold is boosted. </p>

</div>
</div>
<a class="anchor" id="a91ba1935b646d5395b324b0c5f6efa49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::updateMinDutyCyclesGlobal_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the minimum duty cycles in a global fashion. </p>
<p>Sets the minimum duty cycles for the overlap and activation of all columns to be a percent of the maximum in the region, specified by minPctOverlapDutyCycle and minPctActiveDutyCycle respectively. Functionaly it is equivalent to _updateMinDutyCyclesLocal, but this function exploits the globalilty of the compuation to perform it in a straightforward, and more efficient manner. </p>

</div>
</div>
<a class="anchor" id="a3ff87a26bd2b583785a324a1c9237ed5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::updateMinDutyCyclesLocal_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the minimum duty cycles. </p>
<p>The minimum duty cycles are determined locally. Each column's minimum duty cycles are set to be a percent of the maximum duty cycles in the column's neighborhood. Unlike _updateMinDutyCycles </p>

</div>
</div>
<a class="anchor" id="a682ae196f8ca597ed4215c20e5a1078a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nta::algorithms::spatial_pooler::SpatialPooler::updatePermanencesForColumn_ </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="namespacenta.html#a0b438ee0b4c6d825ca71d8fbd8be4886">Real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>raisePerm</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method updates the permanence matrix with a column's new permanence values. </p>
<p>The column is identified by its index, which reflects the row in the matrix, and the permanence is given in 'dense' form, i.e. a full arrray containing all the zeros as well as the non-zero values. It is in charge of implementing 'clipping' - ensuring that the permanence values are always between 0 and 1 - and 'trimming' - enforcing sparsity by zeroing out all permanence values below '_synPermTrimThreshold'. It also maintains the consistency between 'self._permanences' (the matrix storeing the permanence values), 'self._connectedSynapses', (the matrix storing the bits each column is connected to), and 'self._connectedCounts' (an array storing the number of input bits each column is connected to). Every method wishing to modify the permanence matrix should do so through this method. </p><hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>An int vector of permanence values for a column. The array is "dense", i.e. it contains an entry for each input bit, even if the permanence value is 0.</td></tr>
    <tr><td class="paramname">column</td><td>An int number identifying a column in the permanence, potential and connectivity matrices.</td></tr>
    <tr><td class="paramname">raisePerm</td><td>a boolean value indicating whether the permanence values should be raised until a minimum number are synapses are in a connected state. Should be set to 'false' when a direct assignment is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38e9438994e241bc75cb23e868c28c7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacenta.html#a213121a770bfaeb2c7fd30f536d8d2e9">UInt</a> nta::algorithms::spatial_pooler::SpatialPooler::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the version number of this spatial pooler. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer version number. </dd></dl>

<p>Definition at line <a class="el" href="_spatial_pooler_8hpp_source.html#l00290">290</a> of file <a class="el" href="_spatial_pooler_8hpp_source.html">SpatialPooler.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/algorithms/<a class="el" href="_spatial_pooler_8hpp_source.html">SpatialPooler.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 8 2014 17:25:09 for NuPIC Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
